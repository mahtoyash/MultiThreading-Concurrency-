//1: Extending Thread class
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread running: " + Thread.currentThread().getName());
    }
}

//2: Implementing Runnable
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Runnable running: " + Thread.currentThread().getName());
    }
}




// FOR ACTUALLLY STARTING THE THREADS
public class Main {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        t1.start();
        
        Thread t2 = new Thread(new MyRunnable());
        t2.start();
    }
}



ExecutorService 
So it is a framework provided by the java concurrency API to manage and execute submitted tasks without the need
to manually manage thread life cycles.
1. it can efficiently reuses a fixed pool of threads to execute tasks, thereby improving the performances by
reducing the overhead of thread of thread creation, especically for asynchronous tasks.





 Thread-safe Singleton
private Singleton() {}

public static Singleton getInstance() {
    if (instance == null) {
        synchronized(Singleton.class) {
            if (instance == null) {
                instance = new Singleton();
            }
        }
    }
    return instance;
}

2. Read-Write Lock Pattern (Multiple Readers, Single Writer)
import java.util.concurrent.locks.*;
class SharedResource {
private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
private final Lock readLock = rwLock.readLock();
private final Lock writeLock = rwLock.writeLock();
private int value = 0;

public int read() {
    readLock.lock();
    try {
        System.out.println(Thread.currentThread().getName() + " reading: " + value);
        Thread.sleep(100);
        return value;
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return -1;
    } finally {
        readLock.unlock();
    }
}

public void write(int newValue) {
    writeLock.lock();
    try {
        System.out.println(Thread.currentThread().getName() + " writing: " + newValue);
        value = newValue;
        Thread.sleep(200);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    } finally {
        writeLock.unlock();
    }
}
