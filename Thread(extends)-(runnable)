//1: Extending Thread class
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread running: " + Thread.currentThread().getName());
    }
}

//2: Implementing Runnable
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Runnable running: " + Thread.currentThread().getName());
    }
}




// FOR ACTUALLLY STARTING THE THREADS
public class Main {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        t1.start();
        
        Thread t2 = new Thread(new MyRunnable());
        t2.start();
    }
}



ExecutorService 
So it is a framework provided by the java concurrency API to manage and execute submitted tasks without the need
to manually manage thread life cycles.
1. it can efficiently reuses a fixed pool of threads to execute tasks, thereby improving the performances by
reducing the overhead of thread of thread creation, especically for asynchronous tasks.





 Thread-safe Singleton
private Singleton() {}

public static Singleton getInstance() {
    if (instance == null) {
        synchronized(Singleton.class) {
            if (instance == null) {
                instance = new Singleton();
            }
        }
    }
    return instance;
}

2. Read-Write Lock Pattern (Multiple Readers, Single Writer)
import java.util.concurrent.locks.*;
class SharedResource {
private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
private final Lock readLock = rwLock.readLock();
private final Lock writeLock = rwLock.writeLock();
private int value = 0;

public int read() {
    readLock.lock();
    try {
        System.out.println(Thread.currentThread().getName() + " reading: " + value);
        Thread.sleep(100);
        return value;
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return -1;
    } finally {
        readLock.unlock();
    }
}

public void write(int newValue) {
    writeLock.lock();
    try {
        System.out.println(Thread.currentThread().getName() + " writing: " + newValue);
        value = newValue;
        Thread.sleep(200);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    } finally {
        writeLock.unlock();
    }
}


3. Fork-Join Framework for Parallel Processing
import java.util.concurrent.*;
class SumTask extends RecursiveTask<Long> {
private static final int THRESHOLD = 10000;
private final long[] array;
private final int start;
private final int end;

public SumTask(long[] array, int start, int end) {
    this.array = array;
    this.start = start;
    this.end = end;
}

@Override
protected Long compute() {
    if (end - start <= THRESHOLD) {
        // Compute directly
        long sum = 0;
        for (int i = start; i < end; i++) {
            sum += array[i];
        }
        return sum;
    } else {
        // Split task
        int mid = (start + end) / 2;
        SumTask leftTask = new SumTask(array, start, mid);
        SumTask rightTask = new SumTask(array, mid, end);
        
        leftTask.fork(); // Async execution
        long rightResult = rightTask.compute(); // Current thread
        long leftResult = leftTask.join(); // Wait for result
        
        return leftResult + rightResult;
    }
}



4.Custom Thread-Safe Object Pool
import java.util.concurrent.*;
class ObjectPool<T> {
private final BlockingQueue<T> pool;
private final ObjectFactory<T> factory;
private final int maxSize;
private int currentSize = 0;

interface ObjectFactory<T> {
    T create();
}

public ObjectPool(int size, ObjectFactory<T> factory) {
    this.maxSize = size;
    this.factory = factory;
    this.pool = new LinkedBlockingQueue<>(size);
}

public T borrowObject() throws InterruptedException {
    T obj = pool.poll();
    if (obj == null) {
        synchronized(this) {
            if (currentSize < maxSize) {
                obj = factory.create();
                currentSize++;
            } else {
                obj = pool.take(); // Wait for available object
            }
        }
    }
    return obj;
}

public void returnObject(T obj) {
    if (obj != null) {
        try {
            pool.put(obj);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}

public int available() {
    return pool.size();
}



// IMPORTANT - Dining Philosophers Problem Solution
import java.util.concurrent.locks.*;
class Philosopher extends Thread {
private final int id;
private final Lock leftFork;
private final Lock rightFork;
private int mealsEaten = 0;

public Philosopher(int id, Lock leftFork, Lock rightFork) {
    this.id = id;
    this.leftFork = leftFork;
    this.rightFork = rightFork;
}

@Override
public void run() {
    try {
        while (mealsEaten < 5) {
            think();
            eat();
        }
        System.out.println("Philosopher " + id + " finished eating");
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
}

private void think() throws InterruptedException {
    System.out.println("Philosopher " + id + " is thinking");
    Thread.sleep((long)(Math.random() * 100));
}

private void eat() throws InterruptedException {
    // Always acquire locks in same order to prevent deadlock
    Lock first = (id % 2 == 0) ? leftFork : rightFork;
    Lock second = (id % 2 == 0) ? rightFork : leftFork;
    
    first.lock();
    try {
        second.lock();
        try {
            System.out.println("Philosopher " + id + " is eating (meal " + (mealsEaten + 1) + ")");
            Thread.sleep((long)(Math.random() * 100));
            mealsEaten++;
        } finally {
            second.unlock();
        }
    } finally {
        first.unlock();
    }
}
}
// Setup for the logic i applied here,,,
int numPhilosophers = 5;
Lock[] forks = new Lock[numPhilosophers];
Philosopher[] philosophers = new Philosopher[numPhilosophers];
for (int i = 0; i < numPhilosophers; i++) {
forks[i] = new ReentrantLock();
}
for (int i = 0; i < numPhilosophers; i++) {
philosophers[i] = new Philosopher(i, forks[i], forks[(i + 1) % numPhilosophers]);
philosophers[i].start();
}



